scilla_version 0

(***************************************************)
(*               Library                           *)
(***************************************************)
import BoolUtils
library TreasuryLib

(* Global Variables *)
let zero = Uint256 0

(* Library Functions *)
let one_msg =
  fun (msg: Message) =>
  let nil_msg = Nil {Message} in
  Cons {Message} msg nil_msg

(* Error exception *)
type Error =
  | CodeNotAdmin
  | CodeNotFound
  | CodeNotProxy
  | CodeNotPaused
  | CodeIsPaused

let make_error =
  fun (result : Error) =>
    let result_code = 
      match result with
      | CodeNotAdmin             => Int32 -1
      | CodeNotFound             => Int32 -2
      | CodeNotProxy             => Int32 -3
      | CodeNotPaused            => Int32 -4
      | CodeIsPaused             => Int32 -5
      end
    in
    { _exception : "Error"; code : result_code }


(***************************************************)
(*             Contract                            *)
(***************************************************)

contract Treasury

(* Immutable fields declaration *)
(
    init_admin : ByStr20,
    init_company : ByStr20,
    proxy_address : ByStr20,
    token_address: ByStr20,
    base_value: Uint256
)

(* Mutable fields declaration *)

field paused : Bool = True
field under_funded : Bool = True
field admin : ByStr20 = init_admin
field company : ByStr20 = init_company    (* Address of company that receives percentage of tokens distributed *)
field token_price : Uint256 = base_value  (* Price (in ZIL) of a single token *)

(*---------------*)
(*  PROCEDURES   *)
(*---------------*)

procedure ThrowError(err : Error)
  e = make_error err;
  throw e
end

(* Checks if caller is proxy *)
procedure isProxy(address: ByStr20)
  is_proxy = builtin eq proxy_address address;
  match is_proxy with
  | True => (* if True, continue *)
  | False => (* if False, throw error *)
    err = CodeNotProxy;
    ThrowError err
  end
end

procedure IsAdmin()
    currentAdmin <- admin;
    is_admin = builtin eq currentAdmin _sender;
    match is_admin with
    | True => (* if True, continue *)
    | False => (* if False, throw error *)
      err = CodeNotAdmin;
      ThrowError err
    end
end

procedure isPaused()
  is_paused <- paused;
  match is_paused with
  | True =>
  | False =>
    err = CodeNotPaused;
    ThrowError err
  end
end

procedure isNotPaused()
  is_paused <- paused;
  match is_paused with
  | True =>
    err = CodeIsPaused;
    ThrowError err
  | False =>
  end
end

transition Pause(initiator : ByStr20)
  (* Conditional checks *)
  isAdmin;
  isNotPaused;
  
  (* Update state and emits event *)
  paused := true;
  e = { _eventname : "Paused"; sender : initiator};
  event e
end

transition Unpause(initiator : ByStr20)
  (* Conditional checks *)
  isAdmin;
  isPaused;
  
  (* Update state and emits event *)
  paused := false;
  e = {_eventname : "Unpaused"; sender : initiator};
  event e
end

procedure distributeTokens() end    (* Alternative to minting for preminted tokens *)
procedure lockTokensInVault() end   (* Alternative to burning - puts tokens back into treasury vault *)

(* Transfer ZRC-2 Tokens *)
procedure transferTokens(to : ByStr20,  amount : Uint128, tokenAddress : ByStr20)
    IsAdmin;  
    msg = {_tag: "Transfer"; _recipient: tokenAddress; _amount: Uint128 0; to: to; amount: amount};
    msgs = one_msg msg;
    send msgs
end

(* Transfer ZIL *)
procedure Transfer(recipient : ByStr20, amount : Uint128)
  IsAdmin;
  msg = {_tag : "AddFunds"; _recipient : recipient; _amount : amount};
  msgs = one_msg msg;
  send msgs
end

(*---------------*)
(*  TRANSITIONS  *)
(*---------------*)
transition buyTokens() 
  accept

end

transition sellTokens() end
transition payDebt() end
transition createDebt() end
transition cancelDebt() end
transition getDebtDetails() end
transition getDebtAmountPaid() end
transition getDebtCount() end
transition getOutstandingDebtValue() end

(* Accept all ZRC-2 Tokens *)
transition RecipientAcceptTransfer (sender : ByStr20, recipient : ByStr20, amount : Uint128)

end

transition TransferSuccessCallBack (sender : ByStr20, recipient : ByStr20, amount : Uint128)

end